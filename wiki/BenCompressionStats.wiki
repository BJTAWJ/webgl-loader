#summary Compression Stats for ben_00.obj


||              || Raw       || GZIP      || GZIP % ||
|| .OBJ         || 6,387,698 || 1,864,867 || 29.19% ||
|| .JS (32-bit) || 5,275,346 || 1,543,449 || 29.26% ||
|| .JS (16-bit) || 3,074,531 || 963,831   || 31.35% ||
|| UTF-8        || 717,263   || 484,031   || 67.48% ||

*.OBJ* is the original file, found at [http://www.sci.utah.edu/~wald/animrep/ The Utah 3D Animation Repository].

*.JS (32-bit)* is encoded using floats, just like the .OBJ. The big difference in size comes from .OBJs index format. Like most modelling formats, .OBJ uses an index per attribute, rather than per vertex. For example, vertices along a crease can share position indices but have distinct normal or texcoords. During conversion, these vertices end up getting duplicated, but the triangle indices take way less space.

*.JS (16-bit)* uses quantized attributes at the same precision as Google Body. 14-bits per dimension position, and 10-bits per dimension for normals and texcoords. This is probably excess resolution. Body needed 14-bits for position because it had lots of fine features (e.g. blood vessels, nerves), but 10-bits for normals/texcoords were probably too much. At the time, I was particularly concerned about texture warp due to texcoord quantization.

An important note: positions are encoded using uniform quantization. That is, the scale chosen is that of the largest dimension of the bounding box. Effectively, this means fewer bits are allocated to the shorter dimensions.

*UTF-8* uses the compression in this project. Note that it is more effective than GZIP-ing the 16-bit JSON file. This is bit of an unfair comparison, though, since UTF-8 is the only binary-like format. Of course, GZIP still helps a bit!