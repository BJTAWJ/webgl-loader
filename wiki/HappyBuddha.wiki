#summary Loading 1 Million Triangles

First of all, let us not forget [http://goo.gl/body the original milion triangle WebGL program.] Actually, it was more like 1.5 million.

=== Intro ===

Compared to [http://x3dom.org/x3dom/example/x3dom_imageGeometry.html x3dom's image geometry approach], [http://webgl-loader.googlecode.com/svn/trunk/samples/happy/happy.html the webgl-loader approach] should be preferred. Obviously, I'm biased, but there are technical justifications to this belief, aside from the fact that I was able to help launch [http://goo.gl/body Google Body] using similar technology.

For now, ignore the visible chunk boundaries in the x3dom approach. It seems that they aren't correctly quantizing their vertices. However, this is a minor criticism of their implementation, and not their overall technique. I give the nice x3dom folks the benefit of the doubt and assume they will get their seams together, but I feel their technique has a few disadvantages:

=== x3dom image geometry requires vertex texture fetch ===

This has two overlapping problems: support, and performance. OpenGL ES 2.0 and, by consequence, WebGL specify 0 as the minimum number of vertex texture samplers. So, there are no guarantees that you can use this. And even if you could, it won't necessarily be fast. Some implementations report vertex texture fetch support, but emulate it in software. And even those that do, vertex texture fetch is still much slower than simply submitting geometry.

=== x3dom image geometry doesn't use index buffers ===

This disadvantage makes the x3dom technique decidedly different (and inferior) to the similar technique of [http://research.microsoft.com/en-us/um/people/hoppe/proj/gim/ geometry images] which uses implicit connectivity. With index buffers or some kind of connectivity information, the x3dom approach cannot exploit vertex transform caches, and will have to re-process each vertex multiple (!6) times. The vertex-optimized approach of webgl-loader will only process each vertex [FifoCacheAnalysis ~1.2 times], thanks to its vertex cache optimizer.

=== x3dom image geometry creates large numbers of draw batches ===

WebGL performance is often [http://www.google.com/events/io/2011/sessions/webgl-techniques-and-performance.html limited by the number of draw calls you can make]. Because of the low precision (8-bits) of image files, the entire model cannot be served by one large image. Instead the model is chunked into various regions and each are encoded into a local image, each of which are rendered using a separate call. There are 185 batches in their demo.

To some extent, webgl-loader has this problem, too. It uses a fixed point representation, so has to deal with precision loss. More importantly, WebGL cannot draw indexed triangles with more than 65,536 vertices, so a million-triangle model has to be split, no matter what. However, compared to x3dom's 185 chunks, webgl-loader only needs 11, which is close to the minimum possible (if not the minimum). This is because webgl-loader can encode more than 15-bits of precision per attribute, and doesn't need to split the model.

=== webgl-loader isn't done being improved ===

The webgl-loader approach, while already better than x3dom image geometry, will continue to improve. I will improve the algorithm to have better coherence and improve compression. I will eliminate redundant data and decoding work for texture coordinates. I will pipeline decoding to overlap computation and I/O using `XHR.onprogress`. I will add progressive rendering. I will add parallel decoding when `TypedArrays` and `WebWorkers` learn to play nicely with each other. And of course, this will all be available in this library.